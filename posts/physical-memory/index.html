<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Page Table: From Virtual to Physical | dx9</title>
<meta name="keywords" content="">
<meta name="description" content="A blog regarding the Page Table and how Linear Addresses are translated to Physical">
<meta name="author" content="dx9">
<link rel="canonical" href="https://dx9.uk/posts/physical-memory/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dx9.uk/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dx9.uk/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dx9.uk/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dx9.uk/apple-touch-icon.png">
<link rel="mask-icon" href="https://dx9.uk/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://dx9.uk/posts/physical-memory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Page Table: From Virtual to Physical" />
<meta property="og:description" content="A blog regarding the Page Table and how Linear Addresses are translated to Physical" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dx9.uk/posts/physical-memory/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-14T12:45:30+00:00" />
<meta property="article:modified_time" content="2024-04-14T12:45:30+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Page Table: From Virtual to Physical"/>
<meta name="twitter:description" content="A blog regarding the Page Table and how Linear Addresses are translated to Physical"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dx9.uk/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Page Table: From Virtual to Physical",
      "item": "https://dx9.uk/posts/physical-memory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Page Table: From Virtual to Physical",
  "name": "Page Table: From Virtual to Physical",
  "description": "A blog regarding the Page Table and how Linear Addresses are translated to Physical",
  "keywords": [
    
  ],
  "articleBody": "Introduction Hello, in this belong we’ll be talking about the page table and how linear (virtual) addresses are translated to physical addresses. To do this we’re going to have to go into depth about how memory is structured within your computer. This blog will talk about the software and hardware side of this topic.\nPhysical Memory To begin with, we’ll need to be familiar with what physical memory is. Now, Physical Memory is the data stored on your RAM. In a paged memory system, your physical memory is split up into chunks referred to as pages. These pages are managed by the MMU (Memory Management Unit) which is a physical component of your CPU. This is also accompanied by the software side called VMM (Virtual Memory Manager). The page table contains a record of all the pages where it’s all managed, the page table maps virtual addresses (we’ll talk more about this soon) to physical addresses where the data is stored.\nLinear/Virtual Memory Now that we know more about physical memory, we need to discuss Linear Memory. Now, linear memory, as we know, is used in accordance with physical memory. We need to discuss more about why it’s used. The way it’s used is by the VMM. Every process is given its own virtual address space where the size varies depending on what architecture the process is using. In a 32-bit process, the virtual address space typically has a 2-gigabyte range of address space. This goes from 0x00000000 through to 0x7FFFFFFF. In a 64-bit process it’s vastly increased, it typically has a 128-gigabyte range of address space. This goes from 0x00000000000 through 0x7FFFFFFFFFFF. Two processes can have overlapping, or the same, virtual address but the data between both will be different as well as the physical address that backs that page, this is because every process has its unique directory base (cr3). The only times when a page table is shared is through shared memory or if it has a parent process (or an inverted page table but we won’t discuss that here).\nPage Table Okay, so we’ve discussed both virtual \u0026 physical memory. It’s time to now talk more about the page table and how it’s structured within Windows. We’ll be discussing the 4-level page table as we have no need currently to discuss any system larger than 64TB of RAM. aa 4-level paging system will be used to map linear addresses to physical addresses by using the bits of the linear address to specify quite a few different things.\n4KB page : Offsets To start lite, we’re going to be talking about the 4-kilobyte page using the 4-level paging system. This might look a little confusing at first but I will try my best to explain what exactly we’re looking at right now. As we can see at the top, the linear address is split up into multiple sections so let’s talk about it.\nbits 0:11 are used as a page offset, we’ll label it as page_offset. This is used to dictate where the physical address is located in the page. bits 12:20 are used as the table offset, we’ll label it as table_offset. This is used to dictate where the page table entry is. bits 21:29 are used as the directory offset, we’ll label it as directory_offset. This is used to dictate where the page directory entry is bits 30:38 are used as the directory pointer offset, we’ll label it as directory_pointer_offset. This is used to dictate where the page directory pointer entry is bits 39:47 are used as the PML4 offset, we’ll label it as pml4_offset. This is used to dictate where the PML4 entry is. (PML4 stands for page map level 4) 4KB page : Entries Now that we’ve discussed the offset side and how the virtual address is broken down into bits. We’ll now talk about how these offsets are used within this entire translation process in order to figure out the entries. The entries in this context refer to, essentially, what page this virtual address belongs to. This picture above will be referred to a couple of times. It might look confusing at first but, once again, I will try my best to explain the real simplicity of this image. To start off with, if we trace from the bottom up, we can see that the address of the 4KB page frame (the physical address of the page frame) is the base of the page. This is stored within the PTE (Page Table Entry). To get the page table entry we’d have to get the address of the page table which is stored in the PDE (Page Directory Entry). So with this being the common gist of how this is all structured and linked together, we’ll now show the path to get the PTE from the cr3 (control register 3).CR3-\u003ePML4E-\u003ePDPTE-\u003ePDE-\u003ePTE. Now what might be putting you off is, what’s the difference between the offsets and the entries? The entries are the actual entries of the current virtual address’ page that we’re trying to index. We already extracted all the offsets so we can apply this to the actual addresses that we extract from each entry. Since we’re essentially indexing, almost, an array we’re going to need to multiply each offset (index) by 8. Let’s start tracing this down now!\n4KB page : CR3 to PML4E let pml4_offset = //... extracted pml4 bits // assuming we're in the process' context let directory_base : cr3 = __readcr3(); // Add the pml4 index onto the page frame of the directory base // The reason we shift left by 12 bits is because we need to append the first 12 bits that were extracted already let pseudo_addr : u64 = (directory_base.page_frame.rotate_left(12)) + (pml4_offset * 8); // read physical memory to get the pml4 entry let pml4_entry : pml4e = read_physical_mem(pseudo_addr); Voila, this is the general premise of how we get the entries of all the page table sections, let’s continue.\n4KB page : PML4E to PDPTE let pdpt_offset = //... extracted pdpt bits let pml4_entry : pml4e = //... pml4e from previous calculation // Add the pdpt index onto the page frame of the pml4e let pseudo_addr : u64 = (pml4_entry.page_frame.rotate_left(12)) + (pdpt_offset * 8); let pdpt_entry : pdpte = read_physical_mem(pseudo_addr); 4KB page : PDPTE to PDE let pd_offset = //... extracted pd bits let pdpt_entry : pdpte = //... pdpte from previous calculation // Add the pd index onto the page frame of the pdpte let pseudo_addr : u64 = (pdpt_entry.page_frame.rotate_left(12)) + (pde_offset * 8); let pd_entry : pde = read_physical_mem(pseudo_addr); 4KB page : PDE to PTE let pt_offset = //... extracted pt bits let pd_entry : pde = //... pde from previous calculation // Add the pt index onto the page frame of the pde let pseudo_addr : u64 = (pd_entry.page_frame.rotate_left(12)) + (pt_offset * 8); let pt_entry : pte = read_physical_mem(pseudo_addr); 4KB page : PTE to Physical Address let page_offset = //... extracted offset bits let pt_entry : pte //... pte from previous calculation // Now that we've got the address offset and the pte // we can just add that same offset onto the page frame of the PTE // to get the physical address that the virtual address is associated to let physical_address : u64 = (pt_entry.page_frame.rotate_left(12) + page_offset); There we go, we’ve successfully translated a virtual address to a physical address in a 4kb page frame.\n2MB page : Offsets We’ve discussed a 4kb page, but what if the page is 2 MB large? This section of the blog will now detail if a page is 2 MB. The offsets extracted from the virtual address are different as seen in the image below. You’ll notice there is no table entry or offset, that’s because there is no need for it. bits 0:20 are used as a page offset, we’ll label it as page_offset. This is used to dictate where the physical address is located in the page. bits 21:29 are used as the directory offset, we’ll label it as directory_offset. This is used to dictate where the page directory entry is bits 30:38 are used as the directory pointer offset, we’ll label it as directory_pointer_offset. This is used to dictate where the page directory pointer entry is bits 39:47 are used as the PML4 offset, we’ll label it as pml4_offset. This is used to dictate where the PML4 entry is. (PML4 stands for page map level 4) 2MB page : CR3 to PML4E let pml4_offset = //... extracted pml4 bits // assuming we're in the process' context let directory_base : cr3 = __readcr3(); // Add the pml4 index onto the page frame of the directory base let pseudo_addr : u64 = (directory_base.page_frame.rotate_left(12)) + (pml4_offset * 8); // read physical memory to get the pml4 entry let pml4_entry : pml4e = read_physical_mem(pseudo_addr); 2MB page : PML4E to PDPTE let pdpt_offset = //... extracted pdpt bits let pml4_entry : pml4e = //... pml4e from previous calculation // Add the pdpt index onto the page frame of the pml4e let pseudo_addr : u64 = (pml4_entry.page_frame.rotate_left(12)) + (pdpt_offset * 8); let pdpt_entry : pdpte = read_physical_mem(pseudo_addr); 2MB page : PDPTE to PDE let pd_offset = //... extracted pd bits let pdpt_entry : pdpte = //... pdpte from previous calculation // Add the pd index onto the page frame of the pdpte let pseudo_addr : u64 = (pdpt_entry.page_frame.rotate_left(12)) + (pde_offset * 8); let pd_entry : pde = read_physical_mem(pseudo_addr); 2MB page : Understanding the PDE struct This is where it gets different from translating a 4kb page frame. In the PDE struct you’ll notice that there are two different scenarios (excluding if the present bit is not set). The first scenario is if the page is 2mb in size, and the other scenario is if it’s just a regular 4kb page frame. This is dictated by the 8th bit at index 7. 2MB page : Obtaining a 2MB PA So, you might be wondering now - how do we get the physical address of a virtual address within a 2MB page? Simple, we’ll have to convert the current PDE struct to a large one and just extract the page frame from it and shift it according to the 2MB structure.\nlet pd_entry : pde = //... pde from previous calculation // Check if it's a large page if pd_entry.page_size { // Convert to large pde struct let pd_entry_large : large_pde = large_pde::from_u64(pd_entry.raw_value); // extract the page offset let large_page_offset : u64 = (virtual_address \u0026 !((!0u64).rotate_left(21))); // get physical address let physical_address : u64 = (pd_entry_large.page_frame.rotate_left(21) + large_page_offset); } There we go, now we have the physical address of a 2MB page.\n1GB page : Offsets This is essentially going to be the same as 2MB, let’s get started! bits 0:29 are used as a page offset, we’ll label it as page_offset. This is used to dictate where the physical address is located in the page. bits 30:38 are used as the directory pointer offset, we’ll label it as directory_pointer_offset. This is used to dictate where the page directory pointer entry is bits 39:47 are used as the PML4 offset, we’ll label it as pml4_offset. This is used to dictate where the PML4 entry is. (PML4 stands for page map level 4) 1GB page : CR3 to PML4E let pml4_offset = //... extracted pml4 bits // assuming we're in the process' context let directory_base : cr3 = __readcr3(); // Add the pml4 index onto the page frame of the directory base let pseudo_addr : u64 = (directory_base.page_frame.rotate_left(12)) + (pml4_offset * 8); // read physical memory to get the pml4 entry let pml4_entry : pml4e = read_physical_mem(pseudo_addr); 1GB page : PML4E to PDPTE let pdpt_offset = //... extracted pdpt bits let pml4_entry : pml4e = //... pml4e from previous calculation // Add the pdpt index onto the page frame of the pml4e let pseudo_addr : u64 = (pml4_entry.page_frame.rotate_left(12)) + (pdpt_offset * 8); let pdpt_entry : pdpte = read_physical_mem(pseudo_addr); 1GB page : Understanding the PDPTE struct Just like the 2MB page, this is similar with having three possible outcomes. Now since we know the specifics we’ll just get into what bit dictates what. For the PDPTE struct, it’s the same as a 2MB page. The 8th bit (7th index) being set to 1 will say that this is a 1GB page. 1GB page : Obtaining a 1GB PA let pdpt_entry : pdpte = //... pdpte from previous calculation // Check if it's a large page if pdpt_entry.page_size { // Convert to large pdpte struct let pdpt_entry_large : large_pdpte = large_pdpte::from_u64(pdpt_entry.raw_value); // extract the page offset let large_page_offset : u64 = (virtual_address \u0026 !((!0u64).rotate_left(30))); // get physical address let physical_address : u64 = (pdpt_entry_large.page_frame.rotate_left(30) + large_page_offset); } Great, now we have the physical address of a 1GB page.\nConclusion That wraps it all up, this is my take on translating linear addresses into physical and the methodology behind it. I do hope you enjoyed this blog and perhaps learned something new. This is not as detailed as how it works internally but it should give you a good idea. Any mistakes within my work I do apologise and would love for you to correct me! Thank you for reading!\nReferences Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B, 3C, \u0026 3D): System Programming Guide\n",
  "wordCount" : "2216",
  "inLanguage": "en",
  "datePublished": "2024-04-14T12:45:30Z",
  "dateModified": "2024-04-14T12:45:30Z",
  "author":{
    "@type": "Person",
    "name": "dx9"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dx9.uk/posts/physical-memory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "dx9",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dx9.uk/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dx9.uk/" accesskey="h" title="dx9 (Alt + H)">dx9</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Page Table: From Virtual to Physical
    </h1>
    <div class="post-meta"><span title='2024-04-14 12:45:30 +0000 UTC'>April 14, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2216 words&nbsp;·&nbsp;dx9

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#physical-memory">Physical Memory</a></li>
        <li><a href="#linearvirtual-memory">Linear/Virtual Memory</a></li>
        <li><a href="#page-table">Page Table</a>
          <ul>
            <li><a href="#4kb-page--offsets">4KB page : Offsets</a></li>
            <li><a href="#4kb-page--entries">4KB page : Entries</a>
              <ul>
                <li><a href="#4kb-page--cr3-to-pml4e">4KB page : CR3 to PML4E</a></li>
                <li><a href="#4kb-page--pml4e-to-pdpte">4KB page : PML4E to PDPTE</a></li>
                <li><a href="#4kb-page--pdpte-to-pde">4KB page : PDPTE to PDE</a></li>
                <li><a href="#4kb-page--pde-to-pte">4KB page : PDE to PTE</a></li>
                <li><a href="#4kb-page--pte-to-physical-address">4KB page : PTE to Physical Address</a></li>
              </ul>
            </li>
            <li><a href="#2mb-page--offsets">2MB page : Offsets</a>
              <ul>
                <li><a href="#2mb-page--cr3-to-pml4e">2MB page : CR3 to PML4E</a></li>
                <li><a href="#2mb-page--pml4e-to-pdpte">2MB page : PML4E to PDPTE</a></li>
                <li><a href="#2mb-page--pdpte-to-pde">2MB page : PDPTE to PDE</a></li>
                <li><a href="#2mb-page--understanding-the-pde-struct">2MB page : Understanding the PDE struct</a></li>
                <li><a href="#2mb-page--obtaining-a-2mb-pa">2MB page : Obtaining a 2MB PA</a></li>
              </ul>
            </li>
            <li><a href="#1gb-page--offsets">1GB page : Offsets</a>
              <ul>
                <li><a href="#1gb-page--cr3-to-pml4e">1GB page : CR3 to PML4E</a></li>
                <li><a href="#1gb-page--pml4e-to-pdpte">1GB page : PML4E to PDPTE</a></li>
                <li><a href="#1gb-page--understanding-the-pdpte-struct">1GB page : Understanding the PDPTE struct</a></li>
                <li><a href="#1gb-page--obtaining-a-1gb-pa">1GB page : Obtaining a 1GB PA</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#conclusion">Conclusion</a></li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h3>
<p>Hello, in this belong we&rsquo;ll be talking about the page table and how linear (virtual) addresses are translated to physical addresses. To do this we&rsquo;re going to have to go into depth about how memory is structured within your computer. This blog will talk about the software and hardware side of this topic.</p>
<h3 id="physical-memory">Physical Memory<a hidden class="anchor" aria-hidden="true" href="#physical-memory">#</a></h3>
<p>To begin with, we&rsquo;ll need to be familiar with what physical memory is. Now, Physical Memory is the data stored on your RAM. In a paged memory system, your physical memory is split up into chunks referred to as pages. These pages are managed by the MMU (Memory Management Unit) which is a physical component of your CPU. This is also accompanied by the software side called VMM (Virtual Memory Manager). The page table contains a record of all the pages where it&rsquo;s all managed, the page table maps virtual addresses (we&rsquo;ll talk more about this soon) to physical addresses where the data is stored.</p>
<h3 id="linearvirtual-memory">Linear/Virtual Memory<a hidden class="anchor" aria-hidden="true" href="#linearvirtual-memory">#</a></h3>
<p>Now that we know more about physical memory, we need to discuss Linear Memory. Now, linear memory, as we know, is used in accordance with physical memory. We need to discuss more about why it&rsquo;s used. The way it&rsquo;s used is by the VMM. Every process is given its own virtual address space where the size varies depending on what architecture the process is using. In a 32-bit process, the virtual address space typically has a 2-gigabyte range of address space. This goes from <strong>0x00000000</strong> through to <strong>0x7FFFFFFF</strong>. In a 64-bit process it&rsquo;s vastly increased, it typically has a 128-gigabyte range of address space. This goes from <strong>0x00000000000</strong> through <strong>0x7FFFFFFFFFFF</strong>. Two processes can have overlapping, or the same, virtual address but the data between both will be different as well as the physical address that backs that page, this is because every process has its unique directory base (cr3). The only times when a page table is shared is through shared memory or if it has a parent process (or an inverted page table but we won&rsquo;t discuss that here).</p>
<h3 id="page-table">Page Table<a hidden class="anchor" aria-hidden="true" href="#page-table">#</a></h3>
<p>Okay, so we&rsquo;ve discussed both virtual &amp; physical memory. It&rsquo;s time to now talk more about the page table and how it&rsquo;s structured within Windows. We&rsquo;ll be discussing the 4-level page table as we have no need currently to discuss any system larger than 64TB of RAM. aa 4-level paging system will be used to map linear addresses to physical addresses by using the bits of the linear address to specify quite a few different things.</p>
<h4 id="4kb-page--offsets">4KB page : Offsets<a hidden class="anchor" aria-hidden="true" href="#4kb-page--offsets">#</a></h4>
<p>To start lite, we&rsquo;re going to be talking about the 4-kilobyte page using the 4-level paging system.
<a href="/img/figure48.png"><img loading="lazy" src="/img/figure48.png" alt=""  />
</a>
This might look a little confusing at first but I will try my best to explain what exactly we&rsquo;re looking at right now. As we can see at the top, the linear address is split up into multiple sections so let&rsquo;s talk about it.</p>
<ul>
<li>bits 0:11 are used as a page offset, we&rsquo;ll label it as <strong>page_offset</strong>. This is used to dictate where the physical address is located in the page.</li>
<li>bits 12:20 are used as the table offset, we&rsquo;ll label it as <strong>table_offset</strong>. This is used to dictate where the page table entry is.</li>
<li>bits 21:29 are used as the directory offset, we&rsquo;ll label it as <strong>directory_offset</strong>. This is used to dictate where the page directory entry is</li>
<li>bits 30:38 are used as the directory pointer offset, we&rsquo;ll label it as <strong>directory_pointer_offset</strong>. This is used to dictate where the page directory pointer entry is</li>
<li>bits 39:47 are used as the PML4 offset, we&rsquo;ll label it as <strong>pml4_offset</strong>. This is used to dictate where the PML4 entry is. (PML4 stands for page map level 4)</li>
</ul>
<h4 id="4kb-page--entries">4KB page : Entries<a hidden class="anchor" aria-hidden="true" href="#4kb-page--entries">#</a></h4>
<p>Now that we&rsquo;ve discussed the offset side and how the virtual address is broken down into bits. We&rsquo;ll now talk about how these offsets are used within this entire translation process in order to figure out the entries. The entries in this context refer to, essentially, what page this virtual address belongs to.
<a href="/img/figure411.png"><img loading="lazy" src="/img/figure411.png" alt=""  />
</a>
This picture above will be referred to a couple of times. It might look confusing at first but, once again, I will try my best to explain the real simplicity of this image. To start off with, if we trace from the bottom up, we can see that the address of the 4KB page frame (the physical address of the page frame) is the base of the page. This is stored within the PTE (Page Table Entry). To get the page table entry we&rsquo;d have to get the address of the page table which is stored in the PDE (Page Directory Entry). So with this being the common gist of how this is all structured and linked together, we&rsquo;ll now show the path to get the PTE from the cr3 (control register 3).CR3-&gt;PML4E-&gt;PDPTE-&gt;PDE-&gt;PTE. Now what might be putting you off is, what&rsquo;s the difference between the offsets and the entries? The entries are the <strong>actual</strong> entries of the current virtual address&rsquo; page that we&rsquo;re trying to index. We already extracted all the offsets so we can apply this to the actual addresses that we extract from each entry. Since we&rsquo;re essentially indexing, almost, an array we&rsquo;re going to need to multiply each offset (index) by 8. Let&rsquo;s start tracing this down now!</p>
<h5 id="4kb-page--cr3-to-pml4e">4KB page : CR3 to PML4E<a hidden class="anchor" aria-hidden="true" href="#4kb-page--cr3-to-pml4e">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pml4_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pml4 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// assuming we&#39;re in the process&#39; context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> directory_base : <span style="color:#a6e22e">cr3</span> <span style="color:#f92672">=</span> __readcr3();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pml4 index onto the page frame of the directory base
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The reason we shift left by 12 bits is because we need to append the first 12 bits that were extracted already
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (directory_base.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pml4_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// read physical memory to get the pml4 entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pml4_entry : <span style="color:#a6e22e">pml4e</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><p>Voila, this is the general premise of how we get the entries of all the page table sections, let&rsquo;s continue.</p>
<h5 id="4kb-page--pml4e-to-pdpte">4KB page : PML4E to PDPTE<a hidden class="anchor" aria-hidden="true" href="#4kb-page--pml4e-to-pdpte">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pdpt_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pdpt bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pml4_entry : <span style="color:#a6e22e">pml4e</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pml4e from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pdpt index onto the page frame of the pml4e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pml4_entry.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pdpt_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pdpt_entry : <span style="color:#a6e22e">pdpte</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="4kb-page--pdpte-to-pde">4KB page : PDPTE to PDE<a hidden class="anchor" aria-hidden="true" href="#4kb-page--pdpte-to-pde">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pd_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pd bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pdpt_entry : <span style="color:#a6e22e">pdpte</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pdpte from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pd index onto the page frame of the pdpte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pdpt_entry.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pde_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pd_entry : <span style="color:#a6e22e">pde</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="4kb-page--pde-to-pte">4KB page : PDE to PTE<a hidden class="anchor" aria-hidden="true" href="#4kb-page--pde-to-pte">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pt_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pt bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pd_entry : <span style="color:#a6e22e">pde</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pde from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pt index onto the page frame of the pde
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pd_entry.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pt_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pt_entry : <span style="color:#a6e22e">pte</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="4kb-page--pte-to-physical-address">4KB page : PTE to Physical Address<a hidden class="anchor" aria-hidden="true" href="#4kb-page--pte-to-physical-address">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> page_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted offset bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pt_entry : <span style="color:#a6e22e">pte</span> <span style="color:#75715e">//... pte from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Now that we&#39;ve got the address offset and the pte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// we can just add that same offset onto the page frame of the PTE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// to get the physical address that the virtual address is associated to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> physical_address : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pt_entry.page_frame.rotate_left(<span style="color:#ae81ff">12</span>) <span style="color:#f92672">+</span> page_offset);
</span></span></code></pre></div><p>There we go, we&rsquo;ve successfully translated a virtual address to a physical address in a 4kb page frame.</p>
<h4 id="2mb-page--offsets">2MB page : Offsets<a hidden class="anchor" aria-hidden="true" href="#2mb-page--offsets">#</a></h4>
<p>We&rsquo;ve discussed a 4kb page, but what if the page is 2 MB large? This section of the blog will now detail if a page is 2 MB. The offsets extracted from the virtual address are different as seen in the image below. You&rsquo;ll notice there is no table entry or offset, that&rsquo;s because there is no need for it.
<a href="/img/figure49.png"><img loading="lazy" src="/img/figure49.png" alt=""  />
</a></p>
<ul>
<li>bits 0:20 are used as a page offset, we&rsquo;ll label it as <strong>page_offset</strong>. This is used to dictate where the physical address is located in the page.</li>
<li>bits 21:29 are used as the directory offset, we&rsquo;ll label it as <strong>directory_offset</strong>. This is used to dictate where the page directory entry is</li>
<li>bits 30:38 are used as the directory pointer offset, we&rsquo;ll label it as <strong>directory_pointer_offset</strong>. This is used to dictate where the page directory pointer entry is</li>
<li>bits 39:47 are used as the PML4 offset, we&rsquo;ll label it as <strong>pml4_offset</strong>. This is used to dictate where the PML4 entry is. (PML4 stands for page map level 4)</li>
</ul>
<h5 id="2mb-page--cr3-to-pml4e">2MB page : CR3 to PML4E<a hidden class="anchor" aria-hidden="true" href="#2mb-page--cr3-to-pml4e">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pml4_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pml4 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// assuming we&#39;re in the process&#39; context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> directory_base : <span style="color:#a6e22e">cr3</span> <span style="color:#f92672">=</span> __readcr3();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pml4 index onto the page frame of the directory base
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (directory_base.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pml4_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// read physical memory to get the pml4 entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pml4_entry : <span style="color:#a6e22e">pml4e</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="2mb-page--pml4e-to-pdpte">2MB page : PML4E to PDPTE<a hidden class="anchor" aria-hidden="true" href="#2mb-page--pml4e-to-pdpte">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pdpt_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pdpt bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pml4_entry : <span style="color:#a6e22e">pml4e</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pml4e from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pdpt index onto the page frame of the pml4e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pml4_entry.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pdpt_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pdpt_entry : <span style="color:#a6e22e">pdpte</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="2mb-page--pdpte-to-pde">2MB page : PDPTE to PDE<a hidden class="anchor" aria-hidden="true" href="#2mb-page--pdpte-to-pde">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pd_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pd bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pdpt_entry : <span style="color:#a6e22e">pdpte</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pdpte from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pd index onto the page frame of the pdpte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pdpt_entry.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pde_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pd_entry : <span style="color:#a6e22e">pde</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="2mb-page--understanding-the-pde-struct">2MB page : Understanding the PDE struct<a hidden class="anchor" aria-hidden="true" href="#2mb-page--understanding-the-pde-struct">#</a></h5>
<p>This is where it gets different from translating a 4kb page frame. In the PDE struct you&rsquo;ll notice that there are two different scenarios (excluding if the present bit is not set). The first scenario is if the page is 2mb in size, and the other scenario is if it&rsquo;s just a regular 4kb page frame. This is dictated by the 8th bit at index 7.
<a href="/img/figure418.png"><img loading="lazy" src="/img/figure418.png" alt=""  />
</a></p>
<h5 id="2mb-page--obtaining-a-2mb-pa">2MB page : Obtaining a 2MB PA<a hidden class="anchor" aria-hidden="true" href="#2mb-page--obtaining-a-2mb-pa">#</a></h5>
<p>So, you might be wondering now - how do we get the physical address of a virtual address within a 2MB page? Simple, we&rsquo;ll have to convert the current PDE struct to a large one and just extract the page frame from it and shift it according to the 2MB structure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pd_entry : <span style="color:#a6e22e">pde</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pde from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Check if it&#39;s a large page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> pd_entry.page_size {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Convert to large pde struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> pd_entry_large : <span style="color:#a6e22e">large_pde</span> <span style="color:#f92672">=</span> large_pde::from_u64(pd_entry.raw_value);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// extract the page offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> large_page_offset : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (virtual_address <span style="color:#f92672">&amp;</span> <span style="color:#f92672">!</span>((<span style="color:#f92672">!</span><span style="color:#ae81ff">0</span><span style="color:#66d9ef">u64</span>).rotate_left(<span style="color:#ae81ff">21</span>)));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get physical address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> physical_address : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pd_entry_large.page_frame.rotate_left(<span style="color:#ae81ff">21</span>) <span style="color:#f92672">+</span> large_page_offset);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There we go, now we have the physical address of a 2MB page.</p>
<h4 id="1gb-page--offsets">1GB page : Offsets<a hidden class="anchor" aria-hidden="true" href="#1gb-page--offsets">#</a></h4>
<p>This is essentially going to be the same as 2MB, let&rsquo;s get started!
<a href="/img/figure410.png"><img loading="lazy" src="/img/figure410.png" alt=""  />
</a></p>
<ul>
<li>bits 0:29 are used as a page offset, we&rsquo;ll label it as <strong>page_offset</strong>. This is used to dictate where the physical address is located in the page.</li>
<li>bits 30:38 are used as the directory pointer offset, we&rsquo;ll label it as <strong>directory_pointer_offset</strong>. This is used to dictate where the page directory pointer entry is</li>
<li>bits 39:47 are used as the PML4 offset, we&rsquo;ll label it as <strong>pml4_offset</strong>. This is used to dictate where the PML4 entry is. (PML4 stands for page map level 4)</li>
</ul>
<h5 id="1gb-page--cr3-to-pml4e">1GB page : CR3 to PML4E<a hidden class="anchor" aria-hidden="true" href="#1gb-page--cr3-to-pml4e">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pml4_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pml4 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// assuming we&#39;re in the process&#39; context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> directory_base : <span style="color:#a6e22e">cr3</span> <span style="color:#f92672">=</span> __readcr3();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pml4 index onto the page frame of the directory base
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (directory_base.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pml4_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// read physical memory to get the pml4 entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pml4_entry : <span style="color:#a6e22e">pml4e</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="1gb-page--pml4e-to-pdpte">1GB page : PML4E to PDPTE<a hidden class="anchor" aria-hidden="true" href="#1gb-page--pml4e-to-pdpte">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pdpt_offset <span style="color:#f92672">=</span> <span style="color:#75715e">//... extracted pdpt bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pml4_entry : <span style="color:#a6e22e">pml4e</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pml4e from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Add the pdpt index onto the page frame of the pml4e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pseudo_addr : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pml4_entry.page_frame.rotate_left(<span style="color:#ae81ff">12</span>)) <span style="color:#f92672">+</span> (pdpt_offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pdpt_entry : <span style="color:#a6e22e">pdpte</span> <span style="color:#f92672">=</span> read_physical_mem(pseudo_addr);
</span></span></code></pre></div><h5 id="1gb-page--understanding-the-pdpte-struct">1GB page : Understanding the PDPTE struct<a hidden class="anchor" aria-hidden="true" href="#1gb-page--understanding-the-pdpte-struct">#</a></h5>
<p>Just like the 2MB page, this is similar with having three possible outcomes. Now since we know the specifics we&rsquo;ll just get into what bit dictates what. For the PDPTE struct, it&rsquo;s the same as a 2MB page. The 8th bit (7th index) being set to 1 will say that this is a 1GB page.
<a href="/img/figure416.png"><img loading="lazy" src="/img/figure416.png" alt=""  />
</a></p>
<h5 id="1gb-page--obtaining-a-1gb-pa">1GB page : Obtaining a 1GB PA<a hidden class="anchor" aria-hidden="true" href="#1gb-page--obtaining-a-1gb-pa">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pdpt_entry : <span style="color:#a6e22e">pdpte</span> <span style="color:#f92672">=</span> <span style="color:#75715e">//... pdpte from previous calculation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Check if it&#39;s a large page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> pdpt_entry.page_size {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Convert to large pdpte struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> pdpt_entry_large : <span style="color:#a6e22e">large_pdpte</span> <span style="color:#f92672">=</span> large_pdpte::from_u64(pdpt_entry.raw_value);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// extract the page offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> large_page_offset : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (virtual_address <span style="color:#f92672">&amp;</span> <span style="color:#f92672">!</span>((<span style="color:#f92672">!</span><span style="color:#ae81ff">0</span><span style="color:#66d9ef">u64</span>).rotate_left(<span style="color:#ae81ff">30</span>)));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get physical address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> physical_address : <span style="color:#66d9ef">u64</span> <span style="color:#f92672">=</span> (pdpt_entry_large.page_frame.rotate_left(<span style="color:#ae81ff">30</span>) <span style="color:#f92672">+</span> large_page_offset);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Great, now we have the physical address of a 1GB page.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>That wraps it all up, this is my take on translating linear addresses into physical and the methodology behind it. I do hope you enjoyed this blog and perhaps learned something new. This is not as detailed as how it works internally but it should give you a good idea. Any mistakes within my work I do apologise and would love for you to correct me! Thank you for reading!</p>
<h3 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h3>
<p>Intel® 64 and IA-32 Architectures
Software Developer’s Manual
Volume 3 (3A, 3B, 3C, &amp; 3D):
System Programming Guide</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://dx9.uk/">dx9</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
