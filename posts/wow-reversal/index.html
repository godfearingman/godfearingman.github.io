<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>World of Warcraft Calling of Functions (WoTLK 3.3.5) | dx9</title>
<meta name="keywords" content="">
<meta name="description" content="A blog to detail how lua functions are called from a DLL">
<meta name="author" content="dx9">
<link rel="canonical" href="https://dx9.uk/posts/wow-reversal/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dx9.uk/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dx9.uk/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dx9.uk/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dx9.uk/apple-touch-icon.png">
<link rel="mask-icon" href="https://dx9.uk/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://dx9.uk/posts/wow-reversal/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="World of Warcraft Calling of Functions (WoTLK 3.3.5)" />
<meta property="og:description" content="A blog to detail how lua functions are called from a DLL" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dx9.uk/posts/wow-reversal/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-29T16:45:04+00:00" />
<meta property="article:modified_time" content="2023-10-29T16:45:04+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="World of Warcraft Calling of Functions (WoTLK 3.3.5)"/>
<meta name="twitter:description" content="A blog to detail how lua functions are called from a DLL"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dx9.uk/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "World of Warcraft Calling of Functions (WoTLK 3.3.5)",
      "item": "https://dx9.uk/posts/wow-reversal/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "World of Warcraft Calling of Functions (WoTLK 3.3.5)",
  "name": "World of Warcraft Calling of Functions (WoTLK 3.3.5)",
  "description": "A blog to detail how lua functions are called from a DLL",
  "keywords": [
    
  ],
  "articleBody": "Introduction Hello and welcome to my first blog! In this blog, we’ll be talking in detail about how cheaters utilised the famous “FrameScript_ExecuteBuffer” function (Aka lua_dostring) for over a decade in the creation of bots. These bots range from full-blown item-grinding bots used for market gain (Gold resellers must get their gold from somewhere, right) to incredibly smart rotation bots used for personal gain by players in terms of PvP. Even PvE can be cheated in as you’ll see later from our example of the theory behind a healing bot. Not only will we be talking about how cheaters used this function for malicious gain, but we’ll also throw in my personal take on how private servers that currently use older versions of World of Warcraft could potentially patch this and sort out the “Scripting” issue.\nPreface/Theory behind all of this So now that I’ve discussed what I’ll be talking about and the general basis of how prominent this simple trick is in the history of World of Warcraft, let’s get into the theory behind how all of this works. FrameScript_ExecuteBuffer is a function within World of Warcraft’s main module, this C function is, essentially, a modified method similar to lua_dostring, which works the exact same way by taking a script and executing it in the World of Warcraft lua engine. World of Warcraft uses a lua engine for quite a lot of its in-game features. A popular example would be all the addons everyone uses. Now you might be wondering, what stops people from calling the lua functions that we can use to abuse from a mere addon? Simple, some functions that can be used to automate gaming are assigned the “Protected” flag. Now in the next chapter, we’ll talk specifically about what this protected flag actually means and what happens when we try to call those functions from an addon or even a /script “script” call. Protected Functions Now it’s time to talk more about what protected functions are. Blizzard developers saw these functions that players were originally allowed to call in the oldest versions of World of Warcraft and realised, hey this might be a little too overpowered and is causing automation when we strictly prohibit that. What did they end up doing? They decided to start by adding some trivial checks within the C function tied to the lua function. This check merely checked the context in which it was getting called, if it was from an addon or something along those lines - you’d get a generic error saying that you cannot call protected functions. What people originally did to combat this would be what they call “Lua unlockers”. This simply sorted the check out to allow people to continue calling said function. This wasn’t a smart idea as it was incredibly easy to check client modifications for Warden. After people started realising this potentially wasn’t the way, they looked for alternatives. Now, in the Lua C source, there was a function called “luaL_dostring”, this function invokes loadstring and, essentially, executes a script in the lua engine. This was a GOLDMINE for cheaters. They found World of Warcraft’s alternative named “FrameScript_ExecuteBuffer” and decided to start using this to execute malicious Lua scripts. Now you might be wondering, how does this get past the protected flag on the C functions? Simple, the context given was no longer being executed from an addon but rather a context that the check likes. As far as the check saw, it wasn’t an addon calling it and it was a legitimate call made internally.\nDifferent Types of function Flags So, now that we’ve talked about the Protected flag, what other flags are there? Here’s a table with the description. It’s safe to assume you’re able to call almost all functions with these flags through FrameScript_ExecuteBuffer.\nFlag Description BlizzardUI This function is not a C API but a Lua function declared in Blizzard’s default user interface Confirmation This function does not prompt the user for confirmation before its results take effect Deprecated This function is deprecated and is no longer in use Hardware This function requires a key or mouse press in order to be used, but may not be protected Internal This function does nothing in the standard game client and is used by Blizzard for internal purposes LuaApi This function is defined in the Lua Standard Libraries MacOnly This function is designed for the Mac OS X client only NoCombat This function cannot be called during combat Protected This function is protected and can only be called by the Blizzard User Interface Server This function must query the remote server, and any results will not be immediately available to the game client. FrameScript_ExecuteBuffer Enough talking about the LuaApi, let’s talk about what we’re here for. FrameScript_ExecuteBuffer. Now, as I said before - this function is simply a luaL_dostring. We grab our script and run it through this function and we’ll end up executing the script within the context of World of Warcraft. This means we have access to Blizzard’s additional lua library that’s added to vanilla Lua. To complete this, we need to find the address for this function in World of Warcraft’s binary and setup a function delegate and call it. There’s actually another way to call this which was HUGELY popular back in the era this was mainly used in. What developers back in the day did was setup an external C# application which injected shellcode that called the function itself. An example of shellcode used to call this function would be as so;\nmov eax, 0xDEADC0DE ; address of where the script is located in memory push 0 ; will explain the last arg of FrameScript_ExecuteBuffer in the next chapter so don't worry about being confused about these arguments push eax push eax mov eax, 0xDEADBEEF ; address of FrameScript_ExecuteBuffer call eax add esp, 0xC ; Decrement stack pointer retn As we can see here, this was exactly how they would call the function externally. You may be wondering, where are they injecting this shellcode? It’s actually quite funny, this function is pretty good but it has one drawback. It MUST be executed from World of Warcraft’s main thread. This means, you couldn’t simply load your own dll and call it on a separate thread. Alternatively, you couldn’t just write this shellcode to the games memory and use CreateRemoteThread or anything. You had to get this code accessed from the main thread. To solve this, developers either installed temporary hooks on EndScene or flat out had an active hook placed on EndScene where they had this code executing in.\nWhere can we find FrameScript_ExecuteBuffer Now that we understand how FrameScript_ExecuteBuffer reacts and how it was used by previous developers, how do we find the function itself? This might be the funniest part of everything, for such a huge game you’d expect it to be somewhat difficult in finding this extremely overpowered function. Wrong. Let’s dissect the binary using our favourite tool, IDA! After dumping the game using a dumping tool, me personally I enjoy using PD which is a really well written process dumper. Alternatives include Scylla! Now that we’ve loaded the dumped binary into IDA and let it anaylse till idle, let’s open the strings list and find a specific string, “RunScript”. Now this function is tied to the script class and pretty much is just a FrameScript_ExecuteBuffer encased function. Let’s go to the subroutine and see what we can find!\nint __cdecl run_script_4DD490(int a1) { _BYTE *v1; // eax if ( sub_84DF60(a1, 1) ) { v1 = (_BYTE *)sub_84E0E0(a1, 1, 0); if ( v1 ) { if ( *v1 ) sub_819210((int)v1, (int)v1, 0); // Interesting call! } } return 0; } Would you look at that, a suspicious call to another function with arguments that match that of the shellcode I provided above, two of the same arguments \u0026 a argument of 0 at the end. Just like that we found quite possibly one of the most overpowered functions we could for the malicious purpose a cheater would have!\nHow to call FrameScript_ExecuteBuffer Cool, we’ve got the offset. We know under what conditions we need to call it. Let’s piece it all together and write a basic idea on how to call said function. Two ways, either go external and inject shellcode or go internal and call it directly.\nThe internal way Setup a function delegate for FrameScript_ExecuteBuffer Hook EndScene (Either temporarily or permanently) Call function with script passed e.g func_call(“print(‘hello’)”, “print(‘hello’)”, 0); Finished! The external way Create codecave in allocation and write bytes of the script to that codecave Setup shellcode with all arguments needed Inject shellcode with a temporary hook to endscene Finished! Possible ways to detect this We’ve given the cheaters too much credit, if something is easy to do it must be easier to detect right? Yes! There are quite a lot of ways able to detect this. Return checks are definitely an easy way to check the validity of the call. If EndScene is hooked and the return address from the stack is pointing towards EndScene, isn’t that just a little bit suspicious? Why on earth would EndScene want to call a function? As simple as this may be, it’s even simpler to bypass. Cheat developers are nifty, you could simply spoof the return address on the stack to a legit area in the games memory. Another idea could be setting up a VEH handler and placing a debug breakpoint on either RunScript or FrameScript_ExecuteBuffer if EndScene has been hooked (EndScene being hooked is not a good enough reason to call somebody a cheater because a lot of recording applications do this or legitimate internal overlays). If EndScene has been hooked and the breakpoint was hit, we could check the validity of the instruction pointer in the VEH handler to see where this call came from. This is just some basic methods that private servers could utilise because most of the software people use to script on World of Warcraft would definitely fall victim to these methods.\nHandling return values Enough of the methods of preventing it, let’s start getting into some more work of FrameScript_ExecuteBuffer. You might’ve already wondered to yourself, if we had this script;\nsome_return_value_we_need = 12 How do we get the value stored? This is crucial because a lot of the internal Lua functions return some information we need, like getting the health. The solution is a nifty function called GetText. What this function does is, it’ll grab a global variable’s value and return it. Now, how do we find this function? We know that World of Warcraft has some lua functions they’ve written for the blizzard interface (BlizzardUI Flag) and it’s only logical to assume that they do in fact call these functions themselves. How many of these do we think return something they need? A lot. Let’s go back into IDA and look for some suspicious strings. I decided to look at some functions that contain anything to do with the players health, maybe they want to see the players health or any information regarding the player at any point of time. Eventually I found something that looks like it might have something to do with it.\nif ( v142 \u003e 6 ) v33 = \"HEALTH_COST\"; else v33 = *(const char **)\u0026off_AD2EA0[4 * v142]; if ( v142 != 5 ) { if ( v182 \u003e 0 ) { if ( v32 \u003c= 0 ) { if ( v29 ) { v42 = sub_819D40(*(_DWORD *)(v29 + 8), -1, 0); sub_76ED20(Format, v42, 128); v43 = (char *)sub_819D40((int)\"POWER_DISPLAY_COST\", -1, 0); // Looks very interesting sub_76F070((int)v158, 128, v43, v182); } else { v44 = sub_819D40((int)v33, -1, 0); sub_76ED20(Format, v44, 128); sub_76F070((int)v158, 128, Format, v182); } goto LABEL_76; } } Although I didn’t include it, sub_819D40 is called quite a lot and by checking the xrefs it does look like it does exactly as we figured, it’s getting information from the game’s lua context. This is it being called elsewhere.\nv574 = (v573 - 3600) / 60; v575 = (char *)sub_819D40((int)\"INT_SPELL_DURATION_HOURS\", 1, 0); sub_76F070((int)v648, 4096, v575, 1); v576 = (char *)sub_819D40((int)\"INT_SPELL_DURATION_MIN\", v574, 0); Looks like this is our GetText function! It appears to take these arguments\nArg1 -\u003e the global variable’s name Arg2 -\u003e Seems to range between -1, 1 quite a lot Arg3 -\u003e Constantly 0 Calling GetText So now that we have the address of GetText, we can also call this just as we did with FrameScript_ExecuteBuffer. Once again, two ways of doing this - Internal \u0026 Externally.\nThe internal way Setup a function delegate for GetText Hook EndScene (Either temporarily or permanently) Call function with global variable passed e.g int return_from_lua = func_call(“some_return_value_we_need”, -1, 0); Finished! The External way We’ll need to write some new shellcode, so let’s do it.\nmov eax, 0xDEADC0DE ; address of where the global variable is located in memory push 0 push -1 push eax mov eax, 0xDEADBEEF ; address of GetText call eax add esp, 0xC ; Decrement stack pointer retn Just note, you’ll have to read the return as well after injecting this shellcode. We can’t just leave it there!\nCreate codecave in allocation and write bytes of the script to that codecave Setup shellcode with all arguments needed Inject shellcode with a temporary hook to endscene Finished! Theory behind a healbot! So now that we can call any lua function and grab any return value from said function, what can we do? Practicaly everything that a normal player can. For instance, you can create a healbot! Let’s go through the steps how a healbot should typically go. We’re going to act as if a player is at least moving the bot.\nGrab the lowest healthed player. We’d want to do this by percentage rather than raw HP as players will all have different raw HP and some may be less but that’s all depicted by Class, Gear, Talents \u0026 Stats. Check if they’re in range of spell to be casted. Cast a rotation of spells depending on cooldowns \u0026 range. Profit? Now I did mention that this could also be used for PvE, what’s the difference anyway? We’re merely healing a low HP’d target. You could realistically setup any type of bot you wanted to by using TWO functions!\nTesting out a call Now that we’ve got everything ready, let’s do a test call.\nUnitHealth using p_Dostring = int(*)(const char* script, const char* scriptname, int null); static p_Dostring Dostring = reinterpret_cast\u003cp_Dostring\u003e(0x819210); //... using p_GetText = char*(__cdecl*)(char* text, std::uintptr_t unk1, std::uintptr_t unk2); static p_GetText GetText = reinterpret_cast\u003cp_GetText\u003e(0x819D40); //... #DEFINE do_string(script) DoString(script, script, 0) #DEFINE get_text(var) GetText((char*)var, -1, 0) //... IN ENDSCENE HOOK do_string(\"current_player_hp = UnitHealth(\\\"player\\\")\"); std::string player_hp_str = get_text(\"current_player_hp\"); std::printf(\"Player health -\u003e %d\\n\", std::stoi(player_hp_str)); [TOGGLED] Player health -\u003e 34931 PoC Here’s a simple PoC of how a healbot would work.\n// Setup variables std::string group_type = \"(null)\"; int num_of_members = 0; // Get list of teammates DoString(\"num_party = GetNumPartyMembers()\"); std::string num_party = GetText((char*)\"num_party\", -1, 0); DoString(\"num_raid = GetNumRaidMembers()\"); std::string num_raid = GetText((char*)\"num_raid\", -1, 0); // Check if raid if (std::stoi(num_raid) \u003e 0) { // Is a raid group_type = \"raid\"; num_of_members = std::stoi(num_raid); } else { // Is a party group_type = \"party\"; num_of_members = std::stoi(num_party); } Hps.push_back(GetHealth(\"player\")); if (num_of_members) { for (int i = 1; i \u003c= num_of_members; i++) { std::string current_member_tag = group_type + std::to_string(i); int player_hp = GetHealth(current_member_tag.c_str()); if ([current_member_tag]() { char p_hp[255]; sprintf(p_hp, \"range = UnitInRange(\\\"%s\\\")\", current_member_tag.c_str()); DoString(p_hp); return (!strcmp(GetText((char*)\"range\", -1, 0), \"1\")); }()) Hps.push_back(player_hp); else Hps.push_back(0); } } std::string lowest_hp_person; int lowest = GetLowestPlayer(); if (lowest != 0) lowest_hp_person = group_type + std::to_string(GetLowestPlayer()); else lowest_hp_person = \"player\"; int player_hp = GetHealth(lowest_hp_person.c_str()); // Check if player is stunned for (std::string current_spell : negative::dispellable_stuns) { if (lowest_hp_person != \"player\" \u0026\u0026 HasDebuff(lowest_hp_person.c_str(), current_spell.c_str()) \u0026\u0026 IsSpellReady(\"Dispel Magic\")) CastSpell(\"Dispel Magic\", lowest_hp_person.c_str()); } if (InCombat(lowest_hp_person.c_str()) \u0026\u0026 !HasDebuff(lowest_hp_person.c_str(), \"Weakened Soul\")) { CastSpell(\"Power Word: Shield\", lowest_hp_person.c_str()); return _EndScene(pDevice); } if (player_hp \u003c= 40 \u0026\u0026 InCombat(lowest_hp_person.c_str()) \u0026\u0026 IsSpellReady(\"Pain Suppression\")) { CastSpell(\"Pain Suppression\", lowest_hp_person.c_str()); return _EndScene(pDevice); } if (player_hp \u003c= 40 \u0026\u0026 InCombat(lowest_hp_person.c_str()) \u0026\u0026 IsSpellReady(\"Desperate Prayer\") \u0026\u0026 lowest_hp_person == \"player\") { CastSpell(\"Desperate Prayer\", lowest_hp_person.c_str()); return _EndScene(pDevice); } if (player_hp \u003c= 75) { if (IsSpellReady(\"Penance\")) { CastSpell(\"Penance\", lowest_hp_person.c_str()); return _EndScene(pDevice); } else { CastSpell(\"Flash Heal\", lowest_hp_person.c_str()); return _EndScene(pDevice); } } if (player_hp \u003c= 80 \u0026\u0026 InCombat(lowest_hp_person.c_str()) \u0026\u0026 IsSpellReady(\"Prayer of Mending\") \u0026\u0026 !HasBuff(lowest_hp_person.c_str(), \"Prayer of Mending\")) { CastSpell(\"Prayer of Mending\", lowest_hp_person.c_str()); return _EndScene(pDevice); } if (player_hp \u003c= 85 \u0026\u0026 IsSpellReady(\"Renew\") \u0026\u0026 !HasBuff(lowest_hp_person.c_str(), \"Renew\")) { CastSpell(\"Renew\", lowest_hp_person.c_str()); return _EndScene(pDevice); } Although the code is not pretty, this essentially will let a lvl 80 discipline priest heal like an arena champion. It’s amazing how such simple code can have players healing so well. Any function not shown within this simple PoC is essentially calling a function found from the old 2010 Lua Wiki for World of Warcraft.\nConclusion Thank you for reading my first blog, this was made to essentially show just how insecure the older versions of World of Warcraft is, the newer ones are definitely better but still not there as of yet. The reason of this blog is because there is still a HUGE community of players who play on private servers that use older builds of World of Warcraft which are extremely susceptible to this basic yet brutal form of cheating.\n",
  "wordCount" : "2878",
  "inLanguage": "en",
  "datePublished": "2023-10-29T16:45:04Z",
  "dateModified": "2023-10-29T16:45:04Z",
  "author":{
    "@type": "Person",
    "name": "dx9"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dx9.uk/posts/wow-reversal/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "dx9",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dx9.uk/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dx9.uk/" accesskey="h" title="dx9 (Alt + H)">dx9</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      World of Warcraft Calling of Functions (WoTLK 3.3.5)
    </h1>
    <div class="post-meta"><span title='2023-10-29 16:45:04 +0000 UTC'>October 29, 2023</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2878 words&nbsp;·&nbsp;dx9

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#prefacetheory-behind-all-of-this">Preface/Theory behind all of this</a></li>
        <li><a href="#protected-functions">Protected Functions</a></li>
        <li><a href="#different-types-of-function-flags">Different Types of function Flags</a></li>
        <li><a href="#framescript_executebuffer">FrameScript_ExecuteBuffer</a></li>
        <li><a href="#where-can-we-find-framescript_executebuffer">Where can we find FrameScript_ExecuteBuffer</a></li>
        <li><a href="#how-to-call-framescript_executebuffer">How to call FrameScript_ExecuteBuffer</a>
          <ul>
            <li><a href="#the-internal-way">The internal way</a></li>
            <li><a href="#the-external-way">The external way</a></li>
          </ul>
        </li>
        <li><a href="#possible-ways-to-detect-this">Possible ways to detect this</a></li>
        <li><a href="#handling-return-values">Handling return values</a></li>
        <li><a href="#calling-gettext">Calling GetText</a>
          <ul>
            <li>
              <ul>
                <li><a href="#the-internal-way-1">The internal way</a></li>
                <li><a href="#the-external-way-1">The External way</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#theory-behind-a-healbot">Theory behind a healbot!</a></li>
        <li><a href="#testing-out-a-call">Testing out a call</a></li>
        <li><a href="#poc">PoC</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h3>
<p>Hello and welcome to my first blog! In this blog, we&rsquo;ll be talking in detail about how cheaters utilised the famous &ldquo;FrameScript_ExecuteBuffer&rdquo; function (Aka lua_dostring) for over a decade in the creation of bots.
These bots range from full-blown item-grinding bots used for market gain (Gold resellers must get their gold from somewhere, right) to incredibly smart rotation bots used for personal gain by players in terms of PvP. Even PvE can be cheated in as you&rsquo;ll see later from our example of the theory behind a healing bot. Not only will we be talking about how cheaters used this function for malicious gain, but we&rsquo;ll also throw in my personal take on how private servers that currently use older versions of World of Warcraft could potentially patch this and sort out the &ldquo;Scripting&rdquo; issue.</p>
<h3 id="prefacetheory-behind-all-of-this">Preface/Theory behind all of this<a hidden class="anchor" aria-hidden="true" href="#prefacetheory-behind-all-of-this">#</a></h3>
<p>So now that I’ve discussed what I’ll be talking about and the general basis of how prominent this simple trick is in the history of World of Warcraft, let’s get into the theory behind how all of this works. FrameScript_ExecuteBuffer is a function within World of Warcraft’s main module, this C function is, essentially, a modified method similar to lua_dostring, which works the exact same way by taking a script and executing it in the World of Warcraft lua engine. World of Warcraft uses a lua engine for quite a lot of its in-game features. A popular example would be all the addons everyone uses. Now you might be wondering, what stops people from calling the lua functions that we can use to abuse from a mere addon? Simple, some functions that can be used to automate gaming are assigned the “Protected” flag. Now in the next chapter, we’ll talk specifically about what this protected flag actually means and what happens when we try to call those functions from an addon or even a /script “script” call.
<img loading="lazy" src="/img/protected_function_example.png" alt=""  />
</p>
<h3 id="protected-functions">Protected Functions<a hidden class="anchor" aria-hidden="true" href="#protected-functions">#</a></h3>
<p>Now it&rsquo;s time to talk more about what protected functions are. Blizzard developers saw these functions that players were <em>originally</em> allowed to call in the oldest versions of World of Warcraft and realised, hey this might be a little too overpowered and is causing automation when we strictly prohibit that. What did they end up doing? They decided to start by adding some trivial checks within the C function tied to the lua function. This check merely checked the context in which it was getting called, if it was from an addon or something along those lines - you&rsquo;d get a generic error saying that you cannot call protected functions. What people originally did to combat this would be what they call &ldquo;Lua unlockers&rdquo;. This simply sorted the check out to allow people to continue calling said function. This wasn&rsquo;t a smart idea as it was incredibly easy to check client modifications for Warden. After people started realising this potentially wasn&rsquo;t the way, they looked for alternatives. Now, in the Lua C source, there was a function called &ldquo;luaL_dostring&rdquo;, this function invokes loadstring and, essentially, executes a script in the lua engine. This was a GOLDMINE for cheaters. They found World of Warcraft&rsquo;s alternative named &ldquo;FrameScript_ExecuteBuffer&rdquo; and decided to start using this to execute malicious Lua scripts. Now you might be wondering, how does this get past the protected flag on the C functions? Simple, the context given was no longer being executed from an addon but rather a context that the check likes. As far as the check saw, it wasn&rsquo;t an addon calling it and it was a legitimate call made internally.</p>
<h3 id="different-types-of-function-flags">Different Types of function Flags<a hidden class="anchor" aria-hidden="true" href="#different-types-of-function-flags">#</a></h3>
<p>So, now that we&rsquo;ve talked about the Protected flag, what other flags are there? Here&rsquo;s a table with the description. It&rsquo;s safe to assume you&rsquo;re able to call almost all functions with these flags through FrameScript_ExecuteBuffer.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Flag</th>
          <th style="text-align: left">Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">BlizzardUI</td>
          <td style="text-align: left">This function is not a C API but a Lua function declared in Blizzard&rsquo;s default user interface</td>
      </tr>
      <tr>
          <td style="text-align: left">Confirmation</td>
          <td style="text-align: left">This function does not prompt the user for confirmation before its results take effect</td>
      </tr>
      <tr>
          <td style="text-align: left">Deprecated</td>
          <td style="text-align: left">This function is deprecated and is no longer in use</td>
      </tr>
      <tr>
          <td style="text-align: left">Hardware</td>
          <td style="text-align: left">This function requires a key or mouse press in order to be used, but may not be protected</td>
      </tr>
      <tr>
          <td style="text-align: left">Internal</td>
          <td style="text-align: left">This function does nothing in the standard game client and is used by Blizzard for internal purposes</td>
      </tr>
      <tr>
          <td style="text-align: left">LuaApi</td>
          <td style="text-align: left">This function is defined in the Lua Standard Libraries</td>
      </tr>
      <tr>
          <td style="text-align: left">MacOnly</td>
          <td style="text-align: left">This function is designed for the Mac OS X client only</td>
      </tr>
      <tr>
          <td style="text-align: left">NoCombat</td>
          <td style="text-align: left">This function cannot be called during combat</td>
      </tr>
      <tr>
          <td style="text-align: left">Protected</td>
          <td style="text-align: left">This function is protected and can only be called by the Blizzard User Interface</td>
      </tr>
      <tr>
          <td style="text-align: left">Server</td>
          <td style="text-align: left">This function must query the remote server, and any results will not be immediately available to the game client.</td>
      </tr>
  </tbody>
</table>
<h3 id="framescript_executebuffer">FrameScript_ExecuteBuffer<a hidden class="anchor" aria-hidden="true" href="#framescript_executebuffer">#</a></h3>
<p>Enough talking about the LuaApi, let&rsquo;s talk about what we&rsquo;re here for. FrameScript_ExecuteBuffer. Now, as I said before - this function is simply a luaL_dostring. We grab our script and run it through this function and we&rsquo;ll end up executing the script within the context of World of Warcraft. This means we have access to Blizzard&rsquo;s additional lua library that&rsquo;s added to vanilla Lua. To complete this, we need to find the address for this function in World of Warcraft&rsquo;s binary and setup a function delegate and call it. There&rsquo;s actually another way to call this which was HUGELY popular back in the era this was mainly used in. What developers back in the day did was setup an external C# application which injected shellcode that called the function itself. An example of shellcode used to call this function would be as so;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ae81ff">mov eax, 0xDEADC0DE ; address of where the script is located in memory</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">push 0 ; will explain the last arg of FrameScript_ExecuteBuffer in the next chapter so don&#39;t worry about being confused about these arguments</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">push eax</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">push eax</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">mov eax, 0xDEADBEEF ; address of FrameScript_ExecuteBuffer</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">call eax</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">add esp, 0xC ; Decrement stack pointer</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">retn </span>
</span></span></code></pre></div><p>As we can see here, this was exactly how they would call the function externally. You may be wondering, where are they injecting this shellcode? It&rsquo;s actually quite funny, this function is pretty good but it has one drawback. It <strong>MUST</strong> be executed from World of Warcraft&rsquo;s main thread. This means, you couldn&rsquo;t simply load your own dll and call it on a separate thread. Alternatively, you couldn&rsquo;t just write this shellcode to the games memory and use CreateRemoteThread or anything. You <strong>had to get this code accessed from the main thread</strong>. To solve this, developers either installed temporary hooks on EndScene or flat out had an active hook placed on EndScene where they had this code executing in.</p>
<h3 id="where-can-we-find-framescript_executebuffer">Where can we find FrameScript_ExecuteBuffer<a hidden class="anchor" aria-hidden="true" href="#where-can-we-find-framescript_executebuffer">#</a></h3>
<p>Now that we understand how FrameScript_ExecuteBuffer reacts and how it was used by previous developers, how do we find the function itself? This might be the funniest part of everything, for such a huge game you&rsquo;d expect it to be somewhat difficult in finding this extremely overpowered function. Wrong. Let&rsquo;s dissect the binary using our favourite tool, IDA! After dumping the game using a dumping tool, me personally I enjoy using PD which is a really well written process dumper. Alternatives include Scylla! Now that we&rsquo;ve loaded the dumped binary into IDA and let it anaylse till idle, let&rsquo;s open the strings list and find a specific  string, &ldquo;RunScript&rdquo;. Now this function is tied to the script class and pretty much is just a FrameScript_ExecuteBuffer encased function.
<img loading="lazy" src="/img/run_script_string.png" alt=""  />

Let&rsquo;s go to the subroutine and see what we can find!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">run_script_4DD490</span>(<span style="color:#66d9ef">int</span> a1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _BYTE <span style="color:#f92672">*</span>v1; <span style="color:#75715e">// eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">sub_84DF60</span>(a1, <span style="color:#ae81ff">1</span>) )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v1 <span style="color:#f92672">=</span> (_BYTE <span style="color:#f92672">*</span>)<span style="color:#a6e22e">sub_84E0E0</span>(a1, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v1 )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>v1 )
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sub_819210</span>((<span style="color:#66d9ef">int</span>)v1, (<span style="color:#66d9ef">int</span>)v1, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Interesting call!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Would you look at that, a suspicious call to another function with arguments that match that of the shellcode I provided above, two of the same arguments &amp; a argument of 0 at the end. Just like that we found quite possibly one of the most overpowered functions we could for the malicious purpose a cheater would have!</p>
<h3 id="how-to-call-framescript_executebuffer">How to call FrameScript_ExecuteBuffer<a hidden class="anchor" aria-hidden="true" href="#how-to-call-framescript_executebuffer">#</a></h3>
<p>Cool, we&rsquo;ve got the offset. We know under what conditions we need to call it. Let&rsquo;s piece it all together and write a basic idea on how to call said function. Two ways, either go external and inject shellcode or go internal and call it directly.</p>
<h4 id="the-internal-way">The internal way<a hidden class="anchor" aria-hidden="true" href="#the-internal-way">#</a></h4>
<ul>
<li>Setup a function delegate for FrameScript_ExecuteBuffer</li>
<li>Hook EndScene (Either temporarily or permanently)</li>
<li>Call function with script passed e.g func_call(&ldquo;print(&lsquo;hello&rsquo;)&rdquo;, &ldquo;print(&lsquo;hello&rsquo;)&rdquo;, 0);</li>
<li>Finished!</li>
</ul>
<h4 id="the-external-way">The external way<a hidden class="anchor" aria-hidden="true" href="#the-external-way">#</a></h4>
<ul>
<li>Create codecave in allocation and write bytes of the script to that codecave</li>
<li>Setup shellcode with all arguments needed</li>
<li>Inject shellcode with a temporary hook to endscene</li>
<li>Finished!</li>
</ul>
<h3 id="possible-ways-to-detect-this">Possible ways to detect this<a hidden class="anchor" aria-hidden="true" href="#possible-ways-to-detect-this">#</a></h3>
<p>We&rsquo;ve given the cheaters too much credit, if something is easy to do it must be easier to detect right? Yes! There are quite a lot of ways able to detect this. Return checks are definitely an easy way to check the validity of the call. If EndScene is hooked and the return address from the stack is pointing towards EndScene, isn&rsquo;t that just a little bit suspicious? Why on earth would EndScene want to call a function? As simple as this may be, it&rsquo;s even simpler to bypass. Cheat developers are nifty, you could simply spoof the return address on the stack to a legit area in the games memory. Another idea could be setting up a VEH handler and placing a debug breakpoint on either RunScript or FrameScript_ExecuteBuffer if EndScene has been hooked (EndScene being hooked is not a good enough reason to call somebody a cheater because a lot of recording applications do this or legitimate internal overlays). If EndScene has been hooked and the breakpoint was hit, we could check the validity of the instruction pointer in the VEH handler to see where this call came from. This is just some basic methods that private servers could utilise because most of the software people use to script on World of Warcraft would definitely fall victim to these methods.</p>
<h3 id="handling-return-values">Handling return values<a hidden class="anchor" aria-hidden="true" href="#handling-return-values">#</a></h3>
<p>Enough of the methods of preventing it, let&rsquo;s start getting into some more work of FrameScript_ExecuteBuffer. You might&rsquo;ve already wondered to yourself, if we had this script;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>some_return_value_we_need <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span></code></pre></div><p>How do we get the value stored? This is crucial because a lot of the internal Lua functions return some information we need, like getting the health. The solution is a nifty function called <em>GetText</em>. What this function does is, it&rsquo;ll grab a global variable&rsquo;s value and return it. Now, how do we find this function? We know that World of Warcraft has some lua functions they&rsquo;ve written for the blizzard interface (BlizzardUI Flag) and it&rsquo;s only logical to assume that they do in fact call these functions themselves. How many of these do we think return something they need? A lot. Let&rsquo;s go back into IDA and look for some suspicious strings. I decided to look at some functions that contain anything to do with the players health, maybe they want to see the players health or any information regarding the player at any point of time. Eventually I found something that looks like it might have something to do with it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( v142 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">6</span> )
</span></span><span style="display:flex;"><span>      v33 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;HEALTH_COST&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      v33 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>)<span style="color:#f92672">&amp;</span>off_AD2EA0[<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> v142];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( v142 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">5</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> ( v182 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( v32 <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ( v29 )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            v42 <span style="color:#f92672">=</span> <span style="color:#a6e22e">sub_819D40</span>(<span style="color:#f92672">*</span>(_DWORD <span style="color:#f92672">*</span>)(v29 <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sub_76ED20</span>(Format, v42, <span style="color:#ae81ff">128</span>);
</span></span><span style="display:flex;"><span>            v43 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">sub_819D40</span>((<span style="color:#66d9ef">int</span>)<span style="color:#e6db74">&#34;POWER_DISPLAY_COST&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Looks very interesting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">sub_76F070</span>((<span style="color:#66d9ef">int</span>)v158, <span style="color:#ae81ff">128</span>, v43, v182);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            v44 <span style="color:#f92672">=</span> <span style="color:#a6e22e">sub_819D40</span>((<span style="color:#66d9ef">int</span>)v33, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sub_76ED20</span>(Format, v44, <span style="color:#ae81ff">128</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">sub_76F070</span>((<span style="color:#66d9ef">int</span>)v158, <span style="color:#ae81ff">128</span>, Format, v182);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">goto</span> LABEL_76;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span></code></pre></div><p>Although I didn&rsquo;t include it, <strong>sub_819D40</strong> is called quite a lot and by checking the xrefs it does look like it does exactly as we figured, it&rsquo;s getting information from the game&rsquo;s lua context.
This is it being called elsewhere.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>v574 <span style="color:#f92672">=</span> (v573 <span style="color:#f92672">-</span> <span style="color:#ae81ff">3600</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">60</span>;
</span></span><span style="display:flex;"><span>v575 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">sub_819D40</span>((<span style="color:#66d9ef">int</span>)<span style="color:#e6db74">&#34;INT_SPELL_DURATION_HOURS&#34;</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sub_76F070</span>((<span style="color:#66d9ef">int</span>)v648, <span style="color:#ae81ff">4096</span>, v575, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>v576 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">sub_819D40</span>((<span style="color:#66d9ef">int</span>)<span style="color:#e6db74">&#34;INT_SPELL_DURATION_MIN&#34;</span>, v574, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Looks like this is our GetText function! It appears to take these arguments</p>
<ul>
<li>Arg1 -&gt; the global variable&rsquo;s name</li>
<li>Arg2 -&gt; Seems to range between -1, 1 quite a lot</li>
<li>Arg3 -&gt; Constantly 0</li>
</ul>
<h3 id="calling-gettext">Calling GetText<a hidden class="anchor" aria-hidden="true" href="#calling-gettext">#</a></h3>
<p>So now that we have the address of GetText, we can also call this just as we did with FrameScript_ExecuteBuffer. Once again, two ways of doing this - Internal &amp; Externally.</p>
<h5 id="the-internal-way-1">The internal way<a hidden class="anchor" aria-hidden="true" href="#the-internal-way-1">#</a></h5>
<ul>
<li>Setup a function delegate for GetText</li>
<li>Hook EndScene (Either temporarily or permanently)</li>
<li>Call function with global variable passed e.g int return_from_lua = func_call(&ldquo;some_return_value_we_need&rdquo;, -1, 0);</li>
<li>Finished!</li>
</ul>
<h5 id="the-external-way-1">The External way<a hidden class="anchor" aria-hidden="true" href="#the-external-way-1">#</a></h5>
<p>We&rsquo;ll need to write some new shellcode, so let&rsquo;s do it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ae81ff">mov eax, 0xDEADC0DE ; address of where the global variable is located in memory</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">push 0 </span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">push -1 </span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">push eax</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">mov eax, 0xDEADBEEF ; address of GetText</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">call eax</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">add esp, 0xC ; Decrement stack pointer</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">retn </span>
</span></span></code></pre></div><p>Just note, you&rsquo;ll have to read the return as well after injecting this shellcode. We can&rsquo;t just leave it there!</p>
<ul>
<li>Create codecave in allocation and write bytes of the script to that codecave</li>
<li>Setup shellcode with all arguments needed</li>
<li>Inject shellcode with a temporary hook to endscene</li>
<li>Finished!</li>
</ul>
<h3 id="theory-behind-a-healbot">Theory behind a healbot!<a hidden class="anchor" aria-hidden="true" href="#theory-behind-a-healbot">#</a></h3>
<p>So now that we can call any lua function and grab any return value from said function, what can we do? Practicaly everything that a normal player can. For instance, you can create a healbot! Let&rsquo;s go through the steps how a healbot should typically go. We&rsquo;re going to act as if a player is at least moving the bot.</p>
<ol>
<li>Grab the lowest healthed player. We&rsquo;d want to do this by percentage rather than raw HP as players will all have different raw HP and some may be less but that&rsquo;s all depicted by Class, Gear, Talents &amp; Stats.</li>
<li>Check if they&rsquo;re in range of spell to be casted.</li>
<li>Cast a rotation of spells depending on cooldowns &amp; range.</li>
<li>Profit?</li>
</ol>
<p>Now I did mention that this could also be used for PvE, what&rsquo;s the difference anyway? We&rsquo;re merely healing a low HP&rsquo;d target. You could realistically setup any type of bot you wanted to by using TWO functions!</p>
<h3 id="testing-out-a-call">Testing out a call<a hidden class="anchor" aria-hidden="true" href="#testing-out-a-call">#</a></h3>
<p>Now that we&rsquo;ve got everything ready, let&rsquo;s do a test call.</p>
<ul>
<li>UnitHealth</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> p_Dostring <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> script, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> scriptname, <span style="color:#66d9ef">int</span> null);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> p_Dostring Dostring <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>p_Dostring<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0x819210</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> p_GetText <span style="color:#f92672">=</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">__cdecl</span><span style="color:#f92672">*</span>)(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> text, std<span style="color:#f92672">::</span>uintptr_t unk1, std<span style="color:#f92672">::</span>uintptr_t unk2);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> p_GetText GetText <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>p_GetText<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0x819D40</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#DEFINE do_string(script) DoString(script, script, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#DEFINE get_text(var) GetText((char*)var, -1, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//... IN ENDSCENE HOOK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>do_string(<span style="color:#e6db74">&#34;current_player_hp = UnitHealth(</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">player</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">)&#34;</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string player_hp_str <span style="color:#f92672">=</span> get_text(<span style="color:#e6db74">&#34;current_player_hp&#34;</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>printf(<span style="color:#e6db74">&#34;Player health -&gt; %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, std<span style="color:#f92672">::</span>stoi(player_hp_str));
</span></span></code></pre></div><pre tabindex="0"><code>[TOGGLED]
Player health -&gt; 34931
</code></pre><h3 id="poc">PoC<a hidden class="anchor" aria-hidden="true" href="#poc">#</a></h3>
<p>Here&rsquo;s a simple PoC of how a healbot would work.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Setup variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string group_type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(null)&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> num_of_members <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Get list of teammates
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DoString(<span style="color:#e6db74">&#34;num_party = GetNumPartyMembers()&#34;</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string num_party <span style="color:#f92672">=</span> GetText((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#e6db74">&#34;num_party&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DoString(<span style="color:#e6db74">&#34;num_raid = GetNumRaidMembers()&#34;</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string num_raid <span style="color:#f92672">=</span> GetText((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#e6db74">&#34;num_raid&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Check if raid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>stoi(num_raid) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Is a raid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    group_type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;raid&#34;</span>;
</span></span><span style="display:flex;"><span>    num_of_members <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>stoi(num_raid);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Is a party
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    group_type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;party&#34;</span>;
</span></span><span style="display:flex;"><span>    num_of_members <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>stoi(num_party);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Hps.push_back(GetHealth(<span style="color:#e6db74">&#34;player&#34;</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (num_of_members) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> num_of_members; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>string current_member_tag <span style="color:#f92672">=</span> group_type <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> player_hp <span style="color:#f92672">=</span> GetHealth(current_member_tag.c_str());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ([current_member_tag]() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> p_hp[<span style="color:#ae81ff">255</span>];
</span></span><span style="display:flex;"><span>                sprintf(p_hp, <span style="color:#e6db74">&#34;range = UnitInRange(</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">)&#34;</span>, current_member_tag.c_str());
</span></span><span style="display:flex;"><span>                DoString(p_hp);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> (<span style="color:#f92672">!</span>strcmp(GetText((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#e6db74">&#34;range&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>), <span style="color:#e6db74">&#34;1&#34;</span>));
</span></span><span style="display:flex;"><span>            }()) 
</span></span><span style="display:flex;"><span>            Hps.push_back(player_hp);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            Hps.push_back(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string lowest_hp_person;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> lowest <span style="color:#f92672">=</span> GetLowestPlayer();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (lowest <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    lowest_hp_person <span style="color:#f92672">=</span> group_type <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(GetLowestPlayer());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    lowest_hp_person <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;player&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> player_hp <span style="color:#f92672">=</span> GetHealth(lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Check if player is stunned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (std<span style="color:#f92672">::</span>string current_spell : negative<span style="color:#f92672">::</span>dispellable_stuns) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (lowest_hp_person <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;player&#34;</span> <span style="color:#f92672">&amp;&amp;</span> HasDebuff(lowest_hp_person.c_str(), current_spell.c_str()) <span style="color:#f92672">&amp;&amp;</span> IsSpellReady(<span style="color:#e6db74">&#34;Dispel Magic&#34;</span>))
</span></span><span style="display:flex;"><span>        CastSpell(<span style="color:#e6db74">&#34;Dispel Magic&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (InCombat(lowest_hp_person.c_str()) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>HasDebuff(lowest_hp_person.c_str(), <span style="color:#e6db74">&#34;Weakened Soul&#34;</span>)) {
</span></span><span style="display:flex;"><span>    CastSpell(<span style="color:#e6db74">&#34;Power Word: Shield&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_EndScene</span>(pDevice);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (player_hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">40</span> <span style="color:#f92672">&amp;&amp;</span> InCombat(lowest_hp_person.c_str()) <span style="color:#f92672">&amp;&amp;</span> IsSpellReady(<span style="color:#e6db74">&#34;Pain Suppression&#34;</span>)) {
</span></span><span style="display:flex;"><span>    CastSpell(<span style="color:#e6db74">&#34;Pain Suppression&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_EndScene</span>(pDevice);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (player_hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">40</span> <span style="color:#f92672">&amp;&amp;</span> InCombat(lowest_hp_person.c_str()) <span style="color:#f92672">&amp;&amp;</span> IsSpellReady(<span style="color:#e6db74">&#34;Desperate Prayer&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> lowest_hp_person <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;player&#34;</span>) {
</span></span><span style="display:flex;"><span>    CastSpell(<span style="color:#e6db74">&#34;Desperate Prayer&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_EndScene</span>(pDevice);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (player_hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">75</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsSpellReady(<span style="color:#e6db74">&#34;Penance&#34;</span>)) {
</span></span><span style="display:flex;"><span>        CastSpell(<span style="color:#e6db74">&#34;Penance&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_EndScene</span>(pDevice);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        CastSpell(<span style="color:#e6db74">&#34;Flash Heal&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_EndScene</span>(pDevice);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (player_hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">80</span> <span style="color:#f92672">&amp;&amp;</span> InCombat(lowest_hp_person.c_str()) <span style="color:#f92672">&amp;&amp;</span> IsSpellReady(<span style="color:#e6db74">&#34;Prayer of Mending&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>HasBuff(lowest_hp_person.c_str(), <span style="color:#e6db74">&#34;Prayer of Mending&#34;</span>)) {
</span></span><span style="display:flex;"><span>    CastSpell(<span style="color:#e6db74">&#34;Prayer of Mending&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_EndScene</span>(pDevice);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (player_hp <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">85</span> <span style="color:#f92672">&amp;&amp;</span> IsSpellReady(<span style="color:#e6db74">&#34;Renew&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>HasBuff(lowest_hp_person.c_str(), <span style="color:#e6db74">&#34;Renew&#34;</span>)) {
</span></span><span style="display:flex;"><span>    CastSpell(<span style="color:#e6db74">&#34;Renew&#34;</span>, lowest_hp_person.c_str());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_EndScene</span>(pDevice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Although the code is not pretty, this essentially will let a lvl 80 discipline priest heal like an arena champion. It&rsquo;s amazing how such simple code can have players healing so well. Any function not shown within this simple PoC is essentially calling a function found from <a href="https://web.archive.org/web/20100726112636/http://wowprogramming.com/docs/api_categories">the old 2010 Lua Wiki for World of Warcraft</a>.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Thank you for reading my first blog, this was made to essentially show just how insecure the older versions of World of Warcraft is, the newer ones are definitely better but still not there as of yet. The reason of this blog is because there is still a HUGE community of players who play on private servers that use older builds of World of Warcraft which are extremely susceptible to this basic yet brutal form of cheating.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://dx9.uk/">dx9</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
